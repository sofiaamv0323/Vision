var TcHmi;!function(t){let r;!function(t){let r;!function(t){let r;!function(t){class r extends Array{constructor(...t){1===t.length?(super(1),this[0]=t[0]):super(...t)}get x(){return this[0]||0}set x(t){this[0]=t}get y(){return this[1]||0}set y(t){this[1]=t}get z(){return this[2]||0}set z(t){this[2]=t}differsTo(t){return t.x!==this.x||t.y!==this.y}plus(t){return r.fromArray(this.map(((r,s)=>r+(t[s]||0))))}minus(t){return r.fromArray(this.map(((r,s)=>r-(t[s]||0))))}times(t){return r.fromArray(this.map((r=>r*t)))}floor(){return r.fromArray(this.map((t=>Math.floor(t))))}product2d(t){return this.x*t.y-this.y*t.x}product3d(t){return new r(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}l1(){return this.reduce(((t,r)=>t+Math.abs(r)),0)}l2(){return Math.sqrt(this.reduce(((t,r)=>t+Math.pow(r,2)),0))}distanceTo(t){return this.minus(t).l2()}distanceToLine(t){return Math.abs(this.minus(t.start).product2d(t.direction))/t.direction.l2()}abs(){return r.fromArray(this.map((t=>Math.abs(t))))}round(t=0){const s=Math.pow(10,t);return r.fromArray(this.map((t=>Math.round(t*s)/s)))}roundTo(t){const s=Math.pow(10,t);return r.fromArray(this.map((t=>Math.round(t*s)/s)))}toArray(){return 1===this.length?[this.x]:new Array(...this)}copy(){return new r(...this)}compose2d(t,s){const i=(this.y*s.x-this.x*s.y)/(t.y*s.x-t.x*s.y);return Math.abs(s.x)>1e-4?new r(i,(this.x-i*t.x)/s.x):new r(i,(this.y-i*t.y)/s.y)}rotate2d(t){return new r(Math.cos(t)*this.x-Math.sin(t)*this.y,Math.sin(t)*this.x+Math.cos(t)*this.y)}quadrant2d(){return this.x>=0?this.y>=0?1:2:this.y>=0?4:3}getAngle(){const t=Math.atan2(this.y,this.x);return t<Math.PI/2?t+1.5*Math.PI:t-Math.PI/2}static fromArray(t){return new r(...t)}static zeros(t){return r.fromArray(new Array(t).fill(0))}static fromAngle(t){return new r(Math.cos(t),Math.sin(t))}static fromAngleDeg(t){return r.fromAngle(t/180*Math.PI)}static intersection(t,r){const s=t.start,i=t.direction,n=r.start,e=r.direction;return(-s.x*e.y+n.x*e.y+s.y*e.x-n.y*e.x)/(i.x*e.y-i.y*e.x)}static perpendicularDrop(t,r){const s=t.start,i=t.direction,n=r;return(i.x*n.x+i.y*n.y-i.x*s.x-i.y*s.y)/(Math.pow(i.x,2)+Math.pow(i.y,2))}static pointFromLine(t,r){return t.start.plus(t.direction.times(r))}}t.Vector=r}(r=t.Vision||(t.Vision={}))}(r=t.Beckhoff||(t.Beckhoff={}))}(r=t.Controls||(t.Controls={}))}(TcHmi||(TcHmi={}));